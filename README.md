## Threaded Median & Mode

This is code from a class I took a couple years ago where all code was developed on Linux servers.

This program was created to fulfill homework/classroom requirements, not professional development.

Old README/Explanation:

This program is used to take random integer inputs from a file and sort them by using multithreading and quick sort. The code starts by defining the number of threads that are usable by the code itself. This was important to add as a defined variable because we were meant to try sorting the values from the files with different amounts of threads. A struct is then created for the use of these threads containing the start of the array for each thread, the size of the overall array, and the initial array data. These are all separate for each thread so that they can work concurrently. The main function starts by defining variable names and sizes along with initializing the thread ids and arguments. After these are initialized, the file name must be checked to make sure it was provided in the command line and if it is, it is then stored. If the command line code is not provided properly, an error is outputted to the user with the proper usage of how to run this program. With everything working properly, the file is then opened and checked to make sure it is successful, if it is not, another error is thrown to let the user know it couldn't open the file. The first line is then read in to store the size of the array that must be created. Memory is then allocated for the array that will store all the integers from the file. After the array is created, the rest of the file's values are then stored within that array. The array is then split into even blocks for each of the threads to use. Any extra values that weren't within the parameters to be in a block are then added to the final thread. The threads are each created and storing the separate blocks that they must sort using the struct. The sorting process is done using the function qsort() provided by the standard C library. After all values have been sorted in their respective blocks, the threads are then joined back together and freed. After this, indices are created to be able to combine all of the subarrays back into one final array. This is done through a merge sort by checking the values of each block starting from smallest and going until all values are sorted. After the final sorted array has been merged, a calculation is made to find the mode by running through the entire array. This was not the most efficient method, as checking each of the values as they were sorted into the final array would have been more efficient, but I did not see a way to do this with all the if/else statements that were occurring. After the mode has been calculated, the median is then found by finding the middle point in the final array. If the total size of the array is even, it takes the middle two numbers and finds their average, but if the size is odd, it will just take the middle number. The median and mode are then outputted to the user. When the threads were tested using 3 threads, it was slower than the 6 threads, but overall it wasn't that much of a difference. The difference would end up being half a second to a second with each run, but if this program was given and adjusted for even larger sized input files, a significant speed increase would occur.
